from typing import Dict, Tuple
from jax import numpy as jnp, Array
from scipy.constants import c, epsilon_0

class Light:
    def __init__(self, cfg) -> None:
        self.cfg = cfg
        self.E0_source = cfg["units"]["derived"]["E0_source"]
        self.I0 = cfg["units"]["derived"]["I0"]
        self.c = cfg["units"]["derived"]["c"]
        self.w0 = cfg["units"]["derived"]["w0"]
        self.dE0x = jnp.zeros((cfg["grid"]["nx"], cfg["grid"]["ny"]))
        self.x = cfg["grid"]["x"]
        self.y = cfg["grid"]["y"]

    def create_lowpass_filter(self, shape, cutoff_fraction):
        """
        Create a 1D low-pass filter in frequency domain.

        :param shape: (1, n) shape of the field
        :param cutoff_fraction: fraction of Nyquist frequency to use as cutoff (0-1)

        :return: 1D filter array in frequency domain
        """
        _, n = shape

        # Create frequency coordinates
        k = jnp.fft.fftfreq(n, d=1.0)
        k_radial = jnp.abs(k)
        k_max = 0.5  # Maximum frequency (Nyquist)
        cutoff = cutoff_fraction * k_max
        filter_1d = jnp.exp(-((k_radial / cutoff) ** 2))

        # Reshape to match input shape (1, n)
        return filter_1d.reshape(1, -1)

    def lasy_update(self, t, y, light_wave):
        """
        This function propagates the laser in the direction of the beam at time t for lasy's speckled
        laser profile

        :param t: time
        :param y: state variables
        :param light_wave: driver args

        :return: updated laser field
        """
        delta_omega = 0
        c_cgs = 2.99792458e10
        laser_profile = light_wave["laser_profile"]  # LASY speckled profile object

        y_with_expanded_dims = self.y[None, :, None]
        x_with_expanded_dims = jnp.zeros_like(y_with_expanded_dims)
        t_with_expanded_dims = jnp.full_like(y_with_expanded_dims, t)
        E0y = laser_profile.evaluate(
            x_with_expanded_dims, y_with_expanded_dims, t_with_expanded_dims
        )[
            ..., 0
        ]  # Complex envelope from LASY

        # Plane wave energy calculation
        wpe = self.w0 * jnp.sqrt(y["background_density"])[..., None]
        k0 = (
            self.w0
            / self.c
            * jnp.sqrt((1 + 0j + delta_omega) ** 2 - wpe**2 / self.w0**2)
        )
        E0_static = (
            1 + 0j - wpe**2.0 / (self.w0 * (1 + delta_omega)) ** 2
        ) ** -0.25 * self.E0_source
        E0_units = c_cgs * E0_static / 1e-12 / (1e-4) ** 0.5 / 1e6  # cgs -> V/m

        # Normalizes by matching average laser intensity to the average intensity generated by plane wave in ADEPT
        intensity = jnp.abs(epsilon_0 * E0y**2 / 2 * c)
        calc_avg_intensity = jnp.mean(intensity)
        plane_wave_intensity = jnp.abs(epsilon_0 * E0_units**2 / 2 * c)
        plane_wave_avg_intensity = jnp.mean(plane_wave_intensity)
        E0y *= jnp.sqrt(plane_wave_avg_intensity / calc_avg_intensity)

        # Convert field from V/m to the units LPSE uses
        E0y *= 1e6 / c_cgs  # V/m --> (g^0.5 / cm^0.5 s), cgs units

        E0y *= (
            1e-12 * (1e-4) ** 0.5
        )  # (g^0.5 / cm^0.5 s) --> (g^0.5 / um^0.5 ps), LPSE units
        # Filter out high frequency modes
        E0y_fft = jnp.fft.fft(
            E0y, axis=1
        )  # FFT along the second axis since E0y.shape = (1,ny)
        filter = self.create_lowpass_filter(E0y.shape, cutoff_fraction=0.4)
        E0y_filtered_fft = E0y_fft * filter
        # Conserve energy
        init_energy = jnp.sum(jnp.square(E0y_fft))
        filtered_energy = jnp.sum(jnp.square(E0y_filtered_fft))
        E0y_filtered_fft = E0y_filtered_fft / filtered_energy * init_energy
        E0y_filtered = jnp.fft.ifft(E0y_filtered_fft, axis=1)

        # Propagate the field in direction of the beam
        wpe = self.w0 * jnp.sqrt(y["background_density"])
        k0 = (
            self.w0
            / self.c
            * jnp.sqrt((1 + 0j + delta_omega) ** 2 - wpe**2 / self.w0**2)
        )
        propagator = 1j * k0 * self.x[:, None]
        E0xy = E0y_filtered * jnp.exp(propagator)

        return jnp.stack([self.dE0x, E0xy], axis=-1)

    def laser_update(
        self, t: float, y: jnp.ndarray, light_wave: Dict
    ) -> Tuple[jnp.ndarray, jnp.ndarray]:
        """
        This function updates the laser field at time t

        :param t: time
        :param y: state variables
        :return: updated laser field
        """
        # method = "broadcast"
        # if method == "broadcast":

        wpe = self.w0 * jnp.sqrt(y["background_density"])[..., None]
        k0 = (
            self.w0
            / self.c
            * jnp.sqrt(
                (1 + 0j + light_wave["delta_omega"][None, None]) ** 2
                - wpe**2 / self.w0**2
            )
        )

        E0_static = (
            (
                1
                + 0j
                - wpe**2.0
                / (self.w0 * (1 + light_wave["delta_omega"][None, None])) ** 2
            )
            ** -0.25
            * self.E0_source
            * jnp.sqrt(light_wave["intensities"][None, None])
            * jnp.exp(
                1j * k0 * self.x[:, None, None] + 1j * light_wave["phases"][None, None]
            )
        )

        dE0y = E0_static * jnp.exp(
            -1j * light_wave["delta_omega"][None, None] * self.w0 * t
        )
        dE0y = jnp.sum(dE0y, axis=-1)

        # elif method == "map":
        #     wpe = self.w0 * jnp.sqrt(y["background_density"])

        #     def _fn_(light_wave_item):
        #         delta_omega, intensity, initial_phase = light_wave_item
        #         k0 = self.w0 / self.c * jnp.sqrt((1 + 0j + delta_omega) ** 2 - wpe**2 / self.w0**2)
        #         coeff = (1 + 0j - wpe**2.0 / (self.w0 * (1 + delta_omega)) ** 2) ** -0.25
        #         E0_static = (
        #             coeff
        #             * self.E0_source
        #             * jnp.sqrt(intensity)
        #             * jnp.exp(1j * k0 * self.x[:, None] + 1j * initial_phase)
        #         )
        #         dE0y = E0_static * jnp.exp(-1j * delta_omega * self.w0 * t)
        #         return dE0y

        #     dE0y = jmp(
        #         _fn_,
        #         [light_wave["delta_omega"], light_wave["intensities"], light_wave["initial_phase"]],
        #         batch_size=256,
        #     )
        #     dE0y = jnp.sum(dE0y, axis=0)

        # else:
        #     raise NotImplementedError

        return jnp.stack([self.dE0x, dE0y], axis=-1)

    def calc_ey_at_one_point(
        self, t: float, density: Array, light_wave: Dict
    ) -> Tuple[jnp.ndarray, jnp.ndarray]:
        """
        This function is used to calculate the coherence time of the laser

        :param t: time
        :param y: state variables
        :return: updated laser field
        """

        wpe = self.w0 * jnp.sqrt(density)[None, 0, 0]
        k0 = (
            self.w0
            / self.c
            * jnp.sqrt((1 + 0j + light_wave["delta_omega"]) ** 2 - wpe**2 / self.w0**2)
        )
        E0_static = (
            (1 + 0j - wpe**2.0 / (self.w0 * (1 + light_wave["delta_omega"])) ** 2)
            ** -0.25
            * self.E0_source
            * jnp.sqrt(light_wave["intensities"])
            * jnp.exp(1j * k0 * self.x[0] + 1j * light_wave["phases"])
        )
        dE0y = E0_static * jnp.exp(-1j * light_wave["delta_omega"] * self.w0 * t)
        return jnp.sum(dE0y, axis=0)
